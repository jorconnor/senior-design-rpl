{
    "rb.functions": {
        "text": "# Code sourced under MIT license from kovacs/sortable\r\n\r\nmodule Sortable\r\n    def self.included(base)\r\n      base.extend(ClassMethods)\r\n    end\r\n\r\n    module ClassMethods\r\n      # Class method to setup a controller to create a sortable table.\r\n      #\r\n      # usage: sortable_table class_to_tabularize, optional_params\r\n      #\r\n      # simplest example possible:\r\n      #\r\n      # In your controller...\r\n      #\r\n      # sortable_table User\r\n      #\r\n      # This will create a sortable table over all your objects and display all columns.\r\n      # The simplest way to trim down the columns to display is to pass in a parameter specifying which columns\r\n      # on your object you'd like to display:\r\n      #\r\n      # sortable_table User, :display_columns => ['id', 'email', 'name', 'state', 'created_at']\r\n      #\r\n      # This will show the same sortable, searchable, paginated table with only these columns\r\n      #\r\n      # If you need a bit more control over how the objects are fetchd and displayed this is\r\n      # the next simplest example:\r\n      #\r\n      # Override the index action in your controller:\r\n      #\r\n      # def index\r\n      #  get_sorted_objects(params)\r\n      # end\r\n      #\r\n      # In your index action template (within the same controller) put in a helper call to show a sortable table. You can\r\n      # create your own table partial to be used to display the objects. See the sortable/views/sortable/_table.html.erb\r\n      # (which is the default template used by the plugin) for an example.\r\n      #\r\n      # <%= sortable_table %>\r\n      #\r\n      # The view method will automatically generate a paginated, sortable table for the class type declared in the controller\r\n      #\r\n      # optional_params:\r\n      #\r\n      # :per_page - Number of records to show per page. Default is 10\r\n      #\r\n      # The next section deals with how to change what's displayed in the table. The first and simplest option is :display_columns.\r\n      # The more flexible option is to use :table_headings and :sort_map. First we'll go over the simpler option.\r\n      #\r\n      # :display_columns - Specifies which columns that you'd like to display in the table.\r\n      #\r\n      # For more flexibility you can use :table_headings and :sort_map. You would most likely use this when you want to display\r\n      # attributes from more than one object in the same table or if you need more flexibility with regards to sort rules.\r\n      # :table_headings - The table heading label and sort key. Default is all the column names for the given class\r\n      # :sort_map - The mapping between the sort key and the table.column to sort on. Default is all the columns for the given class\r\n      # :include_relations - Relations to include if you choose to display a column in a related object's table\r\n      #\r\n      # :default_sort - The default sorting column and direction when displaying the table without any sort params. Default is 'id DESC'\r\n      #\r\n      # Note: You *must* override both :table_headings and :sort_map if you do choose to override so that\r\n      # the contents of the column headings match up with the contents of the sort_map they associate with.\r\n      # Also if you override :default_sort you'll need to change the :table_headings and :sort_map if the new :default_sort\r\n      # column doesn't currently reside within the :table_heading and :sort_map collections\r\n      #\r\n      # Example of modifying :table_headings or :sort_map :\r\n      #   :table_headings => [['Name', 'name'], ['Status', 'status']]\r\n      #   :sort_map =>  {'name' => ['users.name'],\r\n      #                  'status' => ['users.status']}\r\n      #\r\n      #   Note that both 'name' and 'status' are sort keys that map to both the table heading label and the\r\n      #   database table.column combination that the heading refers to.\r\n      #\r\n      #   Also note that :default_sort now needs to change as well since the table no longer contains the :default_sort\r\n      #   column of 'id':\r\n      #\r\n      #   :default_sort => ['name', 'DESC']\r\n      #\r\n      # Example of modifying :table_headings to include a column from a related object:\r\n      #   :table_headings => [['Name', 'name'], ['Status', 'status'], ['Role', 'role']]\r\n      #   :sort_map =>  {'name' => ['users.name'],\r\n      #                  'status' => ['users.status'],\r\n      #                  'role' => ['roles.role']}\r\n      #\r\n      #   Note that we've now added 'roles.role' to the list of columns to display and sort on. In order to\r\n      #   make the find work properly we also need to include the related object, so we pass in the following param:\r\n      #   :include_relations => [:role]\r\n      #\r\n      #   Perhaps we want to sort by role ascending by default as well. We'd pass the param value:\r\n      #   :default_sort => ['role', 'ASC']\r\n      #\r\n      #   and the table is now sortable by a related object's column and is the default sort value for the table.\r\n      #\r\n      # Search. You can specify what columns are searchable on your objects as follows:\r\n      #   :search_array => ['cablecar_users.username', 'cablecar_users.name']\r\n      #\r\n      # Now search queries will only search username and name for users. By default search is enabled for all columns\r\n      # that are being displayed in the table. This allows you to expand or constrain those values.\r\n      #\r\n      def sortable_table_options\r\n        @@sortable_table_options ||={}\r\n      end\r\n\r\n      def sortable_table(klass, options={})\r\n        # sortable_table_options ||={}\r\n\r\n        sort_map = HashWithIndifferentAccess.new\r\n\r\n        if options[:table_headings] &&\r\n           options[:sort_map]\r\n           table_headings = options[:table_headings]\r\n           sort_map.merge!(options[:sort_map])\r\n        else\r\n          display_columns = options[:display_columns].blank? ? klass.column_names : options[:display_columns]\r\n          table_headings = []\r\n          klass.column_names.each do |att|\r\n            if display_columns.include?(att)\r\n              table_headings << [att.humanize, att]\r\n              sort_map[att] = [\"#{klass.table_name}.#{att}\", 'DESC']\r\n            end\r\n          end\r\n        end\r\n\r\n        column_procs = options[:column_procs].nil? ? {} : options[:column_procs]\r\n        default_sort = options[:default_sort].nil? ? [sort_map.keys.first, 'DESC'] : options[:default_sort]\r\n        per_page = [options[:per_page], klass.per_page, 20].compact.first\r\n        include_relations = options[:include_relations].nil? ? [] : options[:include_relations]\r\n\r\n        search_array = options[:search_array].nil? ? sort_map.values.collect {|v| v[0]} : options[:search_array]\r\n        search_type = options[:search_type].nil? ? 'MYSQL' : options[:search_type]\r\n        search_conditions = options[:search_conditions].nil? ? '' : options[:search_conditions]\r\n\r\n        sortable_table_options[controller_path] = {:class => klass,\r\n                                                     :table_headings => table_headings,\r\n                                                     :default_sort => default_sort,\r\n                                                     :sort_map => sort_map,\r\n                                                     :search_array => search_array,\r\n                                                     :search_type => search_type,\r\n                                                     :search_conditions => search_conditions,\r\n                                                     :column_procs => column_procs,\r\n                                                     :per_page => per_page,\r\n                                                     :include_relations => include_relations}\r\n        module_eval do\r\n          include Sortable::InstanceMethods\r\n        end\r\n\r\n      end\r\n    end\r\n\r\n    module InstanceMethods\r\n      def sortable_class\r\n        self.class.sortable_table_options[controller_path][:class]\r\n      end\r\n\r\n      def sortable_table_headings\r\n        self.class.sortable_table_options[controller_path][:table_headings]\r\n      end\r\n\r\n      def sortable_default_sort\r\n        self.class.sortable_table_options[controller_path][:default_sort]\r\n      end\r\n\r\n      def sortable_sort_map\r\n        self.class.sortable_table_options[controller_path][:sort_map]\r\n      end\r\n\r\n      def sortable_search_array\r\n        self.class.sortable_table_options[controller_path][:search_array]\r\n      end\r\n\r\n      def sortable_search_type\r\n        self.class.sortable_table_options[controller_path][:search_type]\r\n      end\r\n\r\n      def sortable_search_conditions\r\n        self.class.sortable_table_options[controller_path][:search_conditions]\r\n      end\r\n\r\n      def sortable_per_page\r\n        self.class.sortable_table_options[controller_path][:per_page]\r\n      end\r\n\r\n      def sortable_include_relations\r\n        self.class.sortable_table_options[controller_path][:include_relations]\r\n      end\r\n\r\n      def sortable_column_procs\r\n        self.class.sortable_table_options[controller_path][:column_procs]\r\n      end\r\n      # default impl for listing a collection of objects. Override this action in your controller to fetch objects\r\n      # differently and/or to render a different template.\r\n      def index\r\n        get_sorted_objects(params)\r\n        render :template => 'sortable/index'\r\n      end\r\n\r\n      # Users can also pass in optional conditions that are used by the finder method call. For example if only wanted to\r\n      # show the items that had a certain status value you could pass in a condition 'mytable.status == 300' for example\r\n      # as the conditions parameter and when the finder is called the sortable table will only display objects that meet those\r\n      # conditions. Additionally you can paginate and sort the objects that are returned and apply the conditions to them.\r\n      def get_sorted_objects(params, options={})\r\n        objects = options[:objects].nil? ? sortable_class : options[:objects]\r\n        include_rel = options[:include_relations].nil? ? sortable_include_relations : options[:include_relations]\r\n        @headings = options[:table_headings].nil? ? sortable_table_headings : options[:table_headings]\r\n        @column_procs = options[:sortable_column_procs].nil? ? sortable_column_procs : options[:sortable_column_procs]\r\n        sort_map = options[:sort_map].nil? ? sortable_sort_map : HashWithIndifferentAccess.new(options[:sort_map])\r\n        default_sort = options[:default_sort].nil? ? sortable_default_sort : options[:default_sort]\r\n        conditions = options[:conditions].nil? ? '' : options[:conditions]\r\n        search_array = options[:search_array].nil? ? sortable_search_array : options[:search_array]\r\n        search_type = options[:search_type].nil? ? sortable_search_type : options[:search_type]\r\n        search_conditions = options[:search_conditions].nil? ? sortable_search_conditions : options[:search_conditions]\r\n\r\n        conditions = process_search(params, conditions, {:search_array => search_array, :search_type => search_type, :search_conditions => search_conditions})\r\n        items_per_page = options[:per_page].nil? ? sortable_per_page : options[:per_page]\r\n\r\n        @sort_map = sort_map\r\n        sort = process_sort(params, sort_map, default_sort)\r\n        page = params[:page]\r\n        page ||= 1\r\n        # fetch the objects, paginated and sorted as desired along with any extra filtering conditions\r\n        get_paginated_objects(objects, sort, include_rel, conditions, page, items_per_page)\r\n      end\r\n\r\n      private\r\n      def get_paginated_objects(objects, sort, include_rel, conditions, page, items_per_page)\r\n        @objects = objects.paginate(:include => include_rel,\r\n                                 :order => sort,\r\n                                 :conditions => conditions,\r\n                                 :page => page,\r\n                                 :per_page => items_per_page)\r\n      end\r\n\r\n      # supported DB searches\r\n      MYSQL = 'MYSQL'\r\n      POSTGRES = \"POSTGRES\"\r\n\r\n      def process_search(params, conditions, options)\r\n        if !params[:q].blank?\r\n          if !options[:search_conditions].blank?\r\n            conditions = [conditions + \" #{options[:search_conditions]}\"] + [params[:q]]\r\n          else\r\n            search_type = options[:search_type]\r\n            search_array = options[:search_array]\r\n            search_command = search_type == POSTGRES ? 'ILIKE' : 'LIKE'\r\n            search_value = search_type == POSTGRES ? params[:q] : \"%#{params[:q]}%\"\r\n            columns_to_search = ''\r\n            values = Array.new\r\n            if search_array.size == 1\r\n              columns_to_search += search_array.first\r\n              values << search_value\r\n            else\r\n              columns_to_search = search_array.join(\" #{search_command} ? OR \")\r\n              search_array.size.times {|a| values << search_value}\r\n            end\r\n            columns_to_search += \" #{search_command} ? \"\r\n            conditions += ' and' if !conditions.blank?\r\n            conditions = [conditions + ' (' + columns_to_search + ')'] + values\r\n          end\r\n        end\r\n        return conditions\r\n      end\r\n\r\n      def value_provided?(params, name)\r\n        !params[name].nil? && !params[name].empty?\r\n      end\r\n\r\n      def process_sort(params, sort_map, default_sort)\r\n        if params['sort']\r\n          sort = process_sort_param(params['sort'], sort_map)\r\n        else\r\n          # fetch the table.column from the sortmap for the given sort key and append the sort direction\r\n          sort = sort_map[default_sort[0]][0] + ' ' + default_sort[1]\r\n\r\n          # These variables are used in the sort_link_helper and sort_td_class_helper to build the column link headings\r\n          # and create the proper CSS class for the column heading for the case where there is no sort param.\r\n          @default_sort = default_sort[0]\r\n          if default_sort[1] && default_sort[1] == 'DESC'\r\n            @default_sort_key = default_sort[0] + '_reverse'\r\n            @sortclass = 'sortup'\r\n          else\r\n            @default_sort_key = default_sort[0]\r\n            @sortclass = 'sortdown'\r\n          end\r\n        end\r\n        return sort\r\n      end\r\n\r\n      def process_sort_param(sort, sort_map)\r\n        mapKey = get_sort_key(sort)\r\n\r\n        if sort_map[mapKey].nil?\r\n          raise Exception.new(\"Invalid sort parameter passed #{sort}\")\r\n        end\r\n\r\n        result = ''\r\n        sort_array = sort_map[mapKey]\r\n        # this adds support for more than one sort criteria for a given column\r\n        # for example, status DESC, created_at ASC\r\n        if sort_array[0].class == Array\r\n          sorts = sort_array.collect {|sort_value| get_sort_direction(sort, sort_value)}\r\n          result = sorts.join(', ')\r\n        else\r\n          result = get_sort_direction(sort, sort_array)\r\n        end\r\n        result\r\n      end\r\n\r\n      def get_sort_direction(sort, sort_value)\r\n        result = ''\r\n        column = sort_value[0]\r\n        direction = sort_value[1] || 'ASC'\r\n        if /_reverse$/.match(sort)\r\n          direction = direction == 'DESC' ? 'ASC' : 'DESC'\r\n        end\r\n        result += column + ' ' + direction\r\n      end\r\n\r\n      def get_sort_key(sort)\r\n        i = sort.index('_reverse')\r\n        i.blank? ? sort : sort[0, i]\r\n      end\r\n    end\r\n\r\nend\r\n",
        "pos": 1
    }
}
